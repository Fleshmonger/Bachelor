\chapter{Production}
This chapter concerns the creation of units and buildings, including the architecture for its management. First we explain the StarCraft terms of units and their production.

A \emph{Unit} is any player controlled entity, building or not. Some spell effects, like the Terran nuke, are oddly enough also classified as units but they are neither selectable nor controllable. The term unit rarely includes these however. In this paper we sometimes refer to non-buildings as units, which should be clear from context. Buildings are sometimes called structures, usually to avoid confusion between building as a verb and a noun.

\emph{Production} here refers to the player controlled act of creating a new unit. Within StarCraft, producing a building is called \emph{building} and \emph{training} if it is a non-building. Once a unit is created, there is a duration where it is \emph{constructing} before becoming \emph{complete}. A unit cannot execute player commands and has no abilities during construction. Constructing buildings are placed in the world when they are built, while non-buildings are hidden within their constructor. When a non-building is complete, it appears at the nearest free space around its constructor. A unit consumes resources upon production, including supply requirements. A constructing non-building can be canceled for a full refund.

BWAPI notifies the AI module whenever a unit is created or completed in separate events, which can be used to update internal data-structures.

In the following sections we first briefly describe our location in the hierarchy. Then we begin with training of non-buildings, moving on to building structures. Finally we cover expansions and expanding.

\section{Production Architecture}
The \emph{Accountant} module is used for keeping internal track of spent resources and scheduled units. Commanding a unit to build or train will not spend resources until at least the next frame. Therefore it is required to keep internal records of these, otherwise different modules might spend the same resources twice. Unit scheduling is useful in later frames, such that modules do not request the same unit multiple times.

Training is handled by the \emph{Recruiter} module, while building is done by the \emph{Architect}. These are separate modules as the two jobs are very different in implementation. While the Recruiter is quite low in the hierarchy, the Architect is not since it requires workers from the Landlord module. Both are superior to the Accountant.

There is a third module, the \emph{Morpher}, which handles the rare case of a unit that executes a \emph{morph} command. A morphing unit transforms from one type to another, which is most often seen in case of building refineries. Counter-intuitively, the geyser morphs into a refinery and changes ownership to the constructing player, but the refinery is still built by a worker with a build command. The Morpher exclusively monitors morphing units, while the Architect handles the building.

\section{Training Units}
The \emph{Recruiter} needs to be low in the hierarchy, as it needs to be accessed by many other modules. It does not contain an independent AI, acting only through certain events and method calls. The current implementation is generic such that it can handle any train-able unit in the game.

To train units, the steps are twofold: issue the train command to a relevant, available trainer and then monitor the construction.

	\subsection*{Commanding Trainer}
	Some units can train others, such as the depots that train workers. It is almost exclusively structures that can train. A unit can only train one at a time, although multiple can be queued up. Every unit is trained by at most one other unit, so a graph of trainers and trainees would be a \emph{forest} structure.
	
	Notice that it is inefficient to queue training, as this will lock resources. Instead, issuing the train command whenever the trainer is available will keep resources free without resorting to cancellation. It would be better to implement an internal queue if one was needed.
	
	To command the training we require the trainer. For this we would like to keep records of all units capable of training. BWAPI inherently contains the trainer of any given unit type, so using a dictionary of trainers with their types as keys is sufficient and allows fast queries. From this we can search through the set of trainers until we find one that is available and then send the train command. The evaluation of trainers involve verifying the current existence and control of the unit, and ensuring it is not currently training another unit or has been commanded to in this frame.
	
	Searching through the dictionary is logarithmic and iteration through the matching trainers is linear. Evaluating a trainer is constant. Given $n$ total trainers and $m$ matching trainers the final time for training is then $log(n)m$, which could be improved to $m$ with hashing. Neither $n$ or $m$ are usually very large, but $m$ especially is only in the range of zero to four. Insertions and deletions of trainers are both logarithmic to their size.

	\subsection*{Monitoring Trainee}
	The agent needs to know which units are currently scheduled, such that it can include this into its plans. Units could also be destroyed before completion, in which case the agent might need to reschedule.
	
	Once the train command has been issued, the Accountant is notified of the costs and the type.
	
	Upon receiving the event that a unit has been created, the Recruiter frees the resource costs from the Accountant, as the game state by now has withdrawn the costs itself. The Recruiter inserts the unit into a set of incomplete units. When a unit is completed, the Recruiter is notified and removes the unit from the set and from the Accountant. The same happens if the unit is destroyed, which occurs if the trainer was destroyed.
	
	Inserting and removing from the set is logarithmic to the size. The set is never expected to be very large.

\section{Building Structures}
Like training units, building structures is done in two steps: the structure is built and then it is constructed. Contrary to training, structures require both workers and a location to be built. Workers are the only units capable of building structures, and must move to the build location to do so. Terran workers must stay and construct buildings until they are complete and Zerg workers are destroyed upon building, while Protoss require neither.

However, all Protoss structures must be in close proximity to a Pylon when built, and stops functioning without. The only structure exempt from is the depot and the pylon itself. This only becomes important in later stages of the game where Players might have to carefully manage their space. The agent is not expected to build enough buildings for this to be an issue, so it is mostly disregarded. A Protoss structure is considered \emph{powered} when in vicinity of a pylon.

	\subsection*{Structure Placement}
	The Protoss player must place at least one pylon in any area he wishes to build in, and could distance pylons in a base to maximize coverage. Alternatively, if only a few pylons power a structure it creates a liability. The pylon could easily be destroyed to disable the building, which is useful if it is a defensive structure or unit trainer. Fortunately, we expect the agent's bases to be compact enough such that we can place pylons somewhat arbitrarily and still manage to fit needed structures in the region. It is important however to place at least one pylon in a base before other structures can be built, but this is solved by the strategy modules.
	
	Unless a building location is specified, the easiest solution is placing a structure as close as possible to the base location in the desired region. All the workers in the region are usually at the mineral fields by the depot, and therefore will not be far from the placement. The workers and depot become sheltered by the buildings, such that the opponents' troops are forced to move through bottlenecks to get the workers. Even if a region only has one exit, it might be desirable to spread structures as flying units can attack from any angle. Finally, the solution is easily implemented.
	
	There are some exceptions. Depots will always be placed in new base locations and refineries can only be built on of vespene geysers. In both of these cases, the building location will be specified by the superior module ordering the structure.

	The agent attempts all locations in the map in a spiral pattern around the depot, and returns the first location that is available. This is simple, usually cheap but very expensive asymptotically, as it will be linear to the map size. However we never expect to visit anywhere near all the locations, since few tiles in the map cannot be built upon. To determine availability of a location, it must be clear of units and the tile terrain itself must be able to be built upon. Both of these are handled by BWAPI. Note that this solution places structures in a square pattern, which is not actually the closest to the base location except in \emph{taxicap geometry}.

	Placing buildings too close can block passage between them, especially for larger units. The hitbox is arbitrarily different between otherwise equal sized structures in StarCraft, such that some combinations of buildings next to each other will block some units but not necessarily all. This is because the structure hitbox usually does not cover its location completely, allowing some leeway for smaller units.
	
	By placing buildings at least one tile from each other, we ensure all units can easily pass through. This is done by keeping a map of all owned structure locations, where their dimensions are increased by one tile in all directions. If a build location overlaps any of the occupied tiles it is determined as not available. Registering new buildings and querying this is constant time operations, but the space used is linear to the map size. It could be improved by only keeping a map for regions we have bases in, although not an asymptotic improvement.
	
	Additionally the agent avoids placing structures between resources and depots to avoid obstructing workers. By drawing the smallest rectangle including the depot location, geyser(s) and mineral fields, the agent avoids blocking workers by not placing structures within this. Building the rectangle is linear to the amount of items in it and querying it is constant, but we expect the amount of items to be low (ten or less). This structure map is handled by the \emph{Base Manager} module, which the Architect is superior of.
	
	To summarize, if a location is not specified, buildings are placed in a spiral pattern around the depot, distanced by one tile and outside the gathering-zone.

	\subsection*{Aquiring Builder}
	Recall the Task Master module from chapter \ref{ch:resources}. Since all workers are separated in base locations, we can easily pick a worker from the region the building location is. In case of expansions, we pick a worker from the main base. As the task master marks the jobs of all workers, we can pick a worker from either idle, mineral mining or gas harvesting (in that order). This way we do not interrupt other possibly important tasks. The agent searches through the groups until it finds a worker that is not carrying resources, which then becomes the builder and is tasked as such in the Task Master.
	
	The time complexity is linear to the amount of workers in these groups. However, it is probable that less than half the workers are returning resources at any given moment, so it is expected that we only need to check two workers before finding a viable candidate. In case there are idle workers, the operation is constant.
	
	\subsection*{Executing Command}
	Once the builder has been retrieved, it will be commanded to build at the specified location. A player cannot build in hidden terrain, so the worker will first be moved closer to the target location in this case. When the entire placement has been revealed the builder is commanded to build the structure.
	
	The build order will then be stored in a set, containing the structure type, builder and location. Every frame, the Architect verifies the validity of the build orders, including verifying the builder has not been re-tasked. It also reissues commands to builders if required. As with monitoring trainees, incomplete structures are important to keep for the same reasons. In case of structures, there are more things that could go wrong which would incur cancellation of a scheduled structure. The builder might be destroyed or the build location might prove to be invalid upon being revealed.
	
	All invalid orders are removed, forcing superior modules to reissue the build order. This is desired compared to repairing the order, as the build order might no longer be required.
	
	\subsection*{Monitoring Constructions}
	Since Protoss structures auto-construct, the implementation is identical to monitoring trainees with the same time and space complexities.
	
	As mentioned prior however, refineries are handled by the Morpher module. BWAPI is notified when a unit morphs, upon which it is inserted in a set of incomplete morphs. A morphing unit is not considered constructing, although it is incomplete. When a unit is finished morphing, no event is called, therefore forcing the agent to verify all morphs every frame. However, there are very few expected morphing units at any given moment.

\section{Building Expansions}
\emph{Expansions} are additional depots beyond the starting one, built at other resource clusters. One of the most important concepts in StarCraft, expansions allow players to harvest more resources, more efficiently than with one base. These become necessary as the match progresses, especially since the start locations inevitably run out of resources.

Every tournament legal map has a specific expansion called the \emph{natural expansion}. This refers to the closest base location to a player's start location and is easily defended compared to other expansions. It usually has less resources than other expansions to compensate. %TODO Move?

As noted in the resource chapter, it is often profitable and usually necessary to expand resource harvesting to new locations. To avoid transporting cargo all the way between regions, players have to build resource depots near resources. If the internal data structures behind building structures is limited to regions it may be challenging, and it is in our case.

To build an expansion we need the location and the resources.

	\subsection*{Expansion Placement}
	%TODO This is a bad solution!
	There are a few things to take into account when expanding. Obviously we need to expand into a location which is not occupied by enemy forces, especially not if they already have a depot at the desired location. Additional factors are proximity to existing bases, defensibility and resource quantity. Expanding to the natural expansion is usually always the first choice, as it scores high marks on both proximity and defensibility. Usually, the richest base location is in the center and is difficult to defend.
	
	When the agent looks for the next expansion location, it recursively searches neighboring regions from the starting one. The first region which is not already occupied is picked.
	
	\subsection*{Building Depots}
	When BWTA analyzes a map, it marks optimal base locations, where a depots distance to a mineral cluster and geysers are minimized. Usually each region only contains one base location, at least this is the case for all the AI tournament maps.
	
	Building an expansion is then handled by ordering the depot construction at the found base location with a worker from a nearby region. Currently, the agent always picks a worker from the main base, which is not always optimal. A better solution would be recursively searching neighbor regions' base locations in a priority queue, visiting shortest base-to-base distance first. Since workers are approximately at the same position as their related depot, it would find the optimal worker source.

	%Perspective.
	While the \texttt{Architect} handles building the depot like any other structure, the \texttt{Settler} module contains expansion logic and orders the construction. It is not an independent module and does not decide when to expand.